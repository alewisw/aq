<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AQ: AQReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AQ
   &#160;<span id="projectnumber">0.0</span>
   </div>
   <div id="projectbrief">Multi-Producer Concurrent Allocating Queue</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_a_q_reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AQReader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the reader side of a Multi-Producer Concurrent Allocating Queue.  
 <a href="class_a_q_reader.html#details">More...</a></p>

<p><code>#include &lt;AQReader.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AQReader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_a_q_reader.png" usemap="#AQReader_map" alt=""/>
  <map id="AQReader_map" name="AQReader_map">
<area href="class_a_q.html" title="Represents a Multi-Producer Concurrent Allocating Queue. " alt="AQ" shape="rect" coords="0,0,72,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad3ae0e18f1e3fb051e693344ef9989e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_reader.html#ad3ae0e18f1e3fb051e693344ef9989e0">AQReader</a> (void *mem, size_t memSize)</td></tr>
<tr class="memdesc:ad3ae0e18f1e3fb051e693344ef9989e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a queue reader object that uses the passed shared memory region mem of total size memSize bytes.  <a href="#ad3ae0e18f1e3fb051e693344ef9989e0">More...</a><br /></td></tr>
<tr class="separator:ad3ae0e18f1e3fb051e693344ef9989e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c68dce26fb22d1e0cf4afd47457e09a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_reader.html#a2c68dce26fb22d1e0cf4afd47457e09a">~AQReader</a> (void)</td></tr>
<tr class="memdesc:a2c68dce26fb22d1e0cf4afd47457e09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this queue reader.  <a href="#a2c68dce26fb22d1e0cf4afd47457e09a">More...</a><br /></td></tr>
<tr class="separator:a2c68dce26fb22d1e0cf4afd47457e09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3540da41dd5f50f4509bc62b23f2d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_reader.html#a8f3540da41dd5f50f4509bc62b23f2d3">format</a> (uint32_t pageSizeShift, uint32_t commitTimeoutMs, uint32_t options=0)</td></tr>
<tr class="memdesc:a8f3540da41dd5f50f4509bc62b23f2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats the shared memory for this queue so it can be used by the reader and writers.  <a href="#a8f3540da41dd5f50f4509bc62b23f2d3">More...</a><br /></td></tr>
<tr class="separator:a8f3540da41dd5f50f4509bc62b23f2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97babb3a8853758a2c37c68ecd27fe3f"><td class="memItemLeft" align="right" valign="top">const volatile uint32_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_reader.html#a97babb3a8853758a2c37c68ecd27fe3f">commitCounter</a> (void) const </td></tr>
<tr class="memdesc:a97babb3a8853758a2c37c68ecd27fe3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a reference to a memory address that changes whenever an item is committed to the queue.  <a href="#a97babb3a8853758a2c37c68ecd27fe3f">More...</a><br /></td></tr>
<tr class="separator:a97babb3a8853758a2c37c68ecd27fe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6746d86b29c04ff19032106323cdef6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_reader.html#a6746d86b29c04ff19032106323cdef6f">retrieve</a> (<a class="el" href="class_a_q_item.html">AQItem</a> &amp;item)</td></tr>
<tr class="memdesc:a6746d86b29c04ff19032106323cdef6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the next item from the queue.  <a href="#a6746d86b29c04ff19032106323cdef6f">More...</a><br /></td></tr>
<tr class="separator:a6746d86b29c04ff19032106323cdef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5233986e056a2da7f23e282b7a2596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596">release</a> (<a class="el" href="class_a_q_item.html">AQItem</a> &amp;item)</td></tr>
<tr class="memdesc:aad5233986e056a2da7f23e282b7a2596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the passed item so that it can be discarded from the queue.  <a href="#aad5233986e056a2da7f23e282b7a2596">More...</a><br /></td></tr>
<tr class="separator:aad5233986e056a2da7f23e282b7a2596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_a_q"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_a_q')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_a_q.html">AQ</a></td></tr>
<tr class="memitem:a40ff86ec57b5e791b7e20c14e372999f inherit pub_methods_class_a_q"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q.html#a40ff86ec57b5e791b7e20c14e372999f">isFormatted</a> (void) const </td></tr>
<tr class="memdesc:a40ff86ec57b5e791b7e20c14e372999f inherit pub_methods_class_a_q"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the memory for this queue has been correctly formatted.  <a href="#a40ff86ec57b5e791b7e20c14e372999f">More...</a><br /></td></tr>
<tr class="separator:a40ff86ec57b5e791b7e20c14e372999f inherit pub_methods_class_a_q"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d869cae253ba0b35bd92cb38f647fda inherit pub_methods_class_a_q"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q.html#a7d869cae253ba0b35bd92cb38f647fda">isExtendable</a> (void) const </td></tr>
<tr class="memdesc:a7d869cae253ba0b35bd92cb38f647fda inherit pub_methods_class_a_q"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this queue has been formatted with the extendable option.  <a href="#a7d869cae253ba0b35bd92cb38f647fda">More...</a><br /></td></tr>
<tr class="separator:a7d869cae253ba0b35bd92cb38f647fda inherit pub_methods_class_a_q"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47a5c88e8a23ec7a6e05f6d833c7d01 inherit pub_methods_class_a_q"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q.html#ab47a5c88e8a23ec7a6e05f6d833c7d01">pageSize</a> (void) const </td></tr>
<tr class="memdesc:ab47a5c88e8a23ec7a6e05f6d833c7d01 inherit pub_methods_class_a_q"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the size of each page in the queue.  <a href="#ab47a5c88e8a23ec7a6e05f6d833c7d01">More...</a><br /></td></tr>
<tr class="separator:ab47a5c88e8a23ec7a6e05f6d833c7d01 inherit pub_methods_class_a_q"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee7e5627bf61ece4b47712d363aaeb9 inherit pub_methods_class_a_q"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q.html#a0ee7e5627bf61ece4b47712d363aaeb9">pageCount</a> (void) const </td></tr>
<tr class="memdesc:a0ee7e5627bf61ece4b47712d363aaeb9 inherit pub_methods_class_a_q"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the number of pages in the queue.  <a href="#a0ee7e5627bf61ece4b47712d363aaeb9">More...</a><br /></td></tr>
<tr class="separator:a0ee7e5627bf61ece4b47712d363aaeb9 inherit pub_methods_class_a_q"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526b75b1f633fc6f96b6591ff47ef515 inherit pub_methods_class_a_q"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q.html#a526b75b1f633fc6f96b6591ff47ef515">availableSize</a> (void) const </td></tr>
<tr class="memdesc:a526b75b1f633fc6f96b6591ff47ef515 inherit pub_methods_class_a_q"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the current maximum size of a single <a class="el" href="class_a_q_writer.html#a412092999c2edc4612107512c86ab4b9" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> request.  <a href="#a526b75b1f633fc6f96b6591ff47ef515">More...</a><br /></td></tr>
<tr class="separator:a526b75b1f633fc6f96b6591ff47ef515 inherit pub_methods_class_a_q"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b0ae9501fdbc209a26868ff4c64ac3 inherit pub_methods_class_a_q"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q.html#a83b0ae9501fdbc209a26868ff4c64ac3">claimContentionCount</a> (void) const </td></tr>
<tr class="memdesc:a83b0ae9501fdbc209a26868ff4c64ac3 inherit pub_methods_class_a_q"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the number of times contention has occurred during <a class="el" href="class_a_q_writer.html#a412092999c2edc4612107512c86ab4b9" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> calls.  <a href="#a83b0ae9501fdbc209a26868ff4c64ac3">More...</a><br /></td></tr>
<tr class="separator:a83b0ae9501fdbc209a26868ff4c64ac3 inherit pub_methods_class_a_q"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_class_a_q"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_a_q')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_a_q.html">AQ</a></td></tr>
<tr class="memitem:ae5926cd2aa448ec7963d49c91fe0b0aa inherit pub_static_attribs_class_a_q"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q.html#ae5926cd2aa448ec7963d49c91fe0b0aa">OPTION_CRC32</a> = 1 &lt;&lt; 0</td></tr>
<tr class="memdesc:ae5926cd2aa448ec7963d49c91fe0b0aa inherit pub_static_attribs_class_a_q"><td class="mdescLeft">&#160;</td><td class="mdescRight">When formatting a queue set this flag to enable CRC-32 checksum calculation and validation over each item in the queue.  <a href="#ae5926cd2aa448ec7963d49c91fe0b0aa">More...</a><br /></td></tr>
<tr class="separator:ae5926cd2aa448ec7963d49c91fe0b0aa inherit pub_static_attribs_class_a_q"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1b45770a35b703df2b1f1f17ca4745 inherit pub_static_attribs_class_a_q"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q.html#a8c1b45770a35b703df2b1f1f17ca4745">OPTION_LINK_IDENTIFIER</a> = 1 &lt;&lt; 1</td></tr>
<tr class="memdesc:a8c1b45770a35b703df2b1f1f17ca4745 inherit pub_static_attribs_class_a_q"><td class="mdescLeft">&#160;</td><td class="mdescRight">When formatting a queue set this flag to attach a link identifier to each item.  <a href="#a8c1b45770a35b703df2b1f1f17ca4745">More...</a><br /></td></tr>
<tr class="separator:a8c1b45770a35b703df2b1f1f17ca4745 inherit pub_static_attribs_class_a_q"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa41d392733b3f668d4b5be8064e056 inherit pub_static_attribs_class_a_q"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056">OPTION_EXTENDABLE</a> = 1 &lt;&lt; 2</td></tr>
<tr class="memdesc:adaa41d392733b3f668d4b5be8064e056 inherit pub_static_attribs_class_a_q"><td class="mdescLeft">&#160;</td><td class="mdescRight">When formatting a queue set this flag to allow items to be extended in a linked list.  <a href="#adaa41d392733b3f668d4b5be8064e056">More...</a><br /></td></tr>
<tr class="separator:adaa41d392733b3f668d4b5be8064e056 inherit pub_static_attribs_class_a_q"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the reader side of a Multi-Producer Concurrent Allocating Queue. </p>
<p>Given a single memory region only a single reader may read from the queue at any one time. Moreover an object of this class can only be accessed from a single thread at any one time - it is not reentrant. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad3ae0e18f1e3fb051e693344ef9989e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AQReader::AQReader </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a queue reader object that uses the passed shared memory region mem of total size memSize bytes. </p>
<p>This does not read or write the memory - it just sets up the internal pointers and references.</p>
<p>Only a single <a class="el" href="class_a_q_reader.html" title="Implements the reader side of a Multi-Producer Concurrent Allocating Queue. ">AQReader</a> object can be constructed for any one shared memory region. Having more than one <a class="el" href="class_a_q_reader.html" title="Implements the reader side of a Multi-Producer Concurrent Allocating Queue. ">AQReader</a> object results in undefined behavior.</p>
<p>Before the queue can be accesed it must be formatted with <a class="el" href="class_a_q_reader.html#a8f3540da41dd5f50f4509bc62b23f2d3" title="Formats the shared memory for this queue so it can be used by the reader and writers. ">AQReader::format()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>The memory address where the queue is stored. </td></tr>
    <tr><td class="paramname">memSize</td><td>The total size of the memory region where the queue is stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c68dce26fb22d1e0cf4afd47457e09a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AQReader::~AQReader </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this queue reader. </p>
<p>Any outstanding <a class="el" href="class_a_q_item.html" title="Encapsulates the memory for an item that resides with a Multi-Producer Concurrent Allocating Queue...">AQItem</a> objects otained by calling <a class="el" href="class_a_q_reader.html#a6746d86b29c04ff19032106323cdef6f" title="Obtains the next item from the queue. ">retrieve()</a> but not yet released through <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">release()</a> remain as unreleased in the queue. Accessing any of these objects result in undefined behavior.</p>
<p>The underlying memory of the queue is not impacted by this operation. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a97babb3a8853758a2c37c68ecd27fe3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const volatile uint32_t &amp; AQReader::commitCounter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a reference to a memory address that changes whenever an item is committed to the queue. </p>
<p>This can be used as a cheap method of polling for 'item available'.</p>
<p>The main purpose of this is to implement efficient polling: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> pollRetrieve(<a class="code" href="class_a_q_reader.html">AQReader</a>&amp; reader, <a class="code" href="class_a_q_item.html">AQItem</a>&amp; item)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keyword">volatile</span> uint32_t&amp; <a class="code" href="class_a_q_reader.html#a97babb3a8853758a2c37c68ecd27fe3f">commitCounter</a> = reader.<a class="code" href="class_a_q_reader.html#a97babb3a8853758a2c37c68ecd27fe3f">commitCounter</a>();</div><div class="line">    uint32_t count = <a class="code" href="class_a_q_reader.html#a97babb3a8853758a2c37c68ecd27fe3f">commitCounter</a>;</div><div class="line">    <span class="keywordflow">while</span> (!reader.<a class="code" href="class_a_q_reader.html#a6746d86b29c04ff19032106323cdef6f">retrieve</a>(item))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">while</span> (count == commitCounter)</div><div class="line">        {</div><div class="line">            ... perform some other processing, sleep, etc ...</div><div class="line">        }</div><div class="line">        count = <a class="code" href="class_a_q_reader.html#a97babb3a8853758a2c37c68ecd27fe3f">commitCounter</a>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A reference to an integer whose value changes whenever an item is committed to the queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f3540da41dd5f50f4509bc62b23f2d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AQReader::format </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageSizeShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>commitTimeoutMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats the shared memory for this queue so it can be used by the reader and writers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pageSizeShift</td><td>Configures the page size for the queue. The page size is set to 2^pageSizeShift; for example if pageSizeShift is 7 then the page size is 128 bytes. </td></tr>
    <tr><td class="paramname">commitTimeoutMs</td><td>The maximum amount of time that an <a class="el" href="class_a_q_writer_item.html" title="Encapsulates an item is being written to a Multi-Producer Concurrent Allocating Queue. ">AQWriterItem</a> obtained from <a class="el" href="class_a_q_writer.html#a412092999c2edc4612107512c86ab4b9" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> can be held before calling <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>. This time window is how the queue handles writers that terminate (i.e., crash or otherwise) while olding uncommitted <a class="el" href="class_a_q_writer_item.html" title="Encapsulates an item is being written to a Multi-Producer Concurrent Allocating Queue. ">AQWriterItem</a> objects. Holding an item for long than this time can result in it being returned as uncommitted (<a class="el" href="class_a_q_item.html#a09f66df9383cbeec05990270d2517397" title="Determines if this item was committed to the queue with a call to AQWriter::commit(). ">AQItem::isCommitted()</a> returns false). An application that writes to the memory of an <a class="el" href="class_a_q_writer_item.html" title="Encapsulates an item is being written to a Multi-Producer Concurrent Allocating Queue. ">AQWriterItem</a> that was returned as uncommitted causes undefined behavior. As such, for reliable operation, writers must commit their items within the commitTimeoutMs time window after <a class="el" href="class_a_q_writer.html#a412092999c2edc4612107512c86ab4b9" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> returns the item. </td></tr>
    <tr><td class="paramname">options</td><td>The set of options for this queue. This is a bit-mask where the options are joined together by a logical OR operation. Refer to the descriptions of AQ::OPTION_CRC3, <a class="el" href="class_a_q.html#a8c1b45770a35b703df2b1f1f17ca4745" title="When formatting a queue set this flag to attach a link identifier to each item. ">AQ::OPTION_LINK_IDENTIFIER</a>, and <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the queue was formatted or false if it could not be formatted. The queue formatting operation fails when there is not enough space in the queue to setup for the specified configuration. </dd></dl>

</div>
</div>
<a class="anchor" id="aad5233986e056a2da7f23e282b7a2596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AQReader::release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_q_item.html">AQItem</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the passed item so that it can be discarded from the queue. </p>
<p>The item must have been previously obtained via a call to <a class="el" href="class_a_q_reader.html#a6746d86b29c04ff19032106323cdef6f" title="Obtains the next item from the queue. ">retrieve()</a> and not yet been released.</p>
<p>Accessing any of the item memory once <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">release()</a> is called results in undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to release. When this function returns this item is marked as not allocated (<a class="el" href="class_a_q_item.html#a21513e2a0208dbbd000c1821913ff595" title="Determins if this item has been allocated to part of a queue. ">AQItem::isAllocated()</a> returns false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>The passed item was not obtained by <a class="el" href="class_a_q_reader.html#a6746d86b29c04ff19032106323cdef6f" title="Obtains the next item from the queue. ">retrieve()</a> or has already been released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6746d86b29c04ff19032106323cdef6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AQReader::retrieve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_q_item.html">AQItem</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the next item from the queue. </p>
<p>The item argument is populated with the details of the returned item. Once an item is returned it remains valid until <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">release()</a> is called for the item. If retreive() is called again before <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">release()</a> then/ the next available item is returned (given that queue contains any items).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item object to fill with the detail of the retrieved item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an item was obtained or false if no item was available in the queue.If there are no items in the </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_a_q_unformatted_exception.html" title="The exception that is thrown when an attempt is made to access an unformatted queue. ">AQUnformattedException</a></td><td>When the queue is not formatted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>AQReader.h</li>
<li>AQReader.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 1 2016 11:36:08 for AQ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
