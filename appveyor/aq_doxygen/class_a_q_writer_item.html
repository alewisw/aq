<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AQ: AQWriterItem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AQ
   &#160;<span id="projectnumber">0.0</span>
   </div>
   <div id="projectbrief">Multi-Producer Concurrent Allocating Queue</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_a_q_writer_item-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AQWriterItem Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates an item is being written to a Multi-Producer Concurrent Allocating Queue.  
 <a href="class_a_q_writer_item.html#details">More...</a></p>

<p><code>#include &lt;AQWriterItem.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AQWriterItem:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_a_q_writer_item.png" usemap="#AQWriterItem_map" alt=""/>
  <map id="AQWriterItem_map" name="AQWriterItem_map">
<area href="class_a_q_item.html" title="Encapsulates the memory for an item that resides with a Multi-Producer Concurrent Allocating Queue..." alt="AQItem" shape="rect" coords="0,0,87,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afdcdefe235f169332e99ea46160f4445"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#afdcdefe235f169332e99ea46160f4445">AQWriterItem</a> (void)</td></tr>
<tr class="memdesc:afdcdefe235f169332e99ea46160f4445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new item with no initial allocation.  <a href="#afdcdefe235f169332e99ea46160f4445">More...</a><br /></td></tr>
<tr class="separator:afdcdefe235f169332e99ea46160f4445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb89ea3ad90a751066342f136fe4b2fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#afb89ea3ad90a751066342f136fe4b2fd">AQWriterItem</a> (const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> &amp;other)</td></tr>
<tr class="memdesc:afb89ea3ad90a751066342f136fe4b2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new item so that it is an exact copy of another item.  <a href="#afb89ea3ad90a751066342f136fe4b2fd">More...</a><br /></td></tr>
<tr class="separator:afb89ea3ad90a751066342f136fe4b2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626754df58bf7442942ffcde296aac36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a626754df58bf7442942ffcde296aac36">operator=</a> (const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> &amp;other)</td></tr>
<tr class="memdesc:a626754df58bf7442942ffcde296aac36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns this item so that it is an exact copy of another item.  <a href="#a626754df58bf7442942ffcde296aac36">More...</a><br /></td></tr>
<tr class="separator:a626754df58bf7442942ffcde296aac36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6599e6e588dacf5cc51974a0caeea7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#aaf6599e6e588dacf5cc51974a0caeea7">~AQWriterItem</a> (void)</td></tr>
<tr class="memdesc:aaf6599e6e588dacf5cc51974a0caeea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this item.  <a href="#aaf6599e6e588dacf5cc51974a0caeea7">More...</a><br /></td></tr>
<tr class="separator:aaf6599e6e588dacf5cc51974a0caeea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f19448fb3ca5fd9e1afbeb7d60027a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a52f19448fb3ca5fd9e1afbeb7d60027a">setLinkIdentifier</a> (uint32_t lkid)</td></tr>
<tr class="memdesc:a52f19448fb3ca5fd9e1afbeb7d60027a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the link identifier for this item.  <a href="#a52f19448fb3ca5fd9e1afbeb7d60027a">More...</a><br /></td></tr>
<tr class="separator:a52f19448fb3ca5fd9e1afbeb7d60027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab025ce2d8f8ec5716b97a6d8cfd6056a"><td class="memItemLeft" align="right" valign="top">const unsigned char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#ab025ce2d8f8ec5716b97a6d8cfd6056a">operator[]</a> (size_t idx) const </td></tr>
<tr class="memdesc:ab025ce2d8f8ec5716b97a6d8cfd6056a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a reference to one of the bytes within this item.  <a href="#ab025ce2d8f8ec5716b97a6d8cfd6056a">More...</a><br /></td></tr>
<tr class="separator:ab025ce2d8f8ec5716b97a6d8cfd6056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1cf82c67ef0f1aa6a52786124d2d64"><td class="memItemLeft" align="right" valign="top">unsigned char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a4b1cf82c67ef0f1aa6a52786124d2d64">operator[]</a> (size_t idx)</td></tr>
<tr class="memdesc:a4b1cf82c67ef0f1aa6a52786124d2d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a reference to one of the bytes within this item.  <a href="#a4b1cf82c67ef0f1aa6a52786124d2d64">More...</a><br /></td></tr>
<tr class="separator:a4b1cf82c67ef0f1aa6a52786124d2d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d5dcc6535fbbc3f06bc2a56ed2ae18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a06d5dcc6535fbbc3f06bc2a56ed2ae18">write</a> (const void *mem, size_t memSize)</td></tr>
<tr class="memdesc:a06d5dcc6535fbbc3f06bc2a56ed2ae18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data into this item at its current write position.  <a href="#a06d5dcc6535fbbc3f06bc2a56ed2ae18">More...</a><br /></td></tr>
<tr class="separator:a06d5dcc6535fbbc3f06bc2a56ed2ae18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108cb5fa1ed80fd8dab609581283010d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a108cb5fa1ed80fd8dab609581283010d">write</a> (size_t off, const void *mem, size_t memSize)</td></tr>
<tr class="memdesc:a108cb5fa1ed80fd8dab609581283010d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data into this item at a selected position.  <a href="#a108cb5fa1ed80fd8dab609581283010d">More...</a><br /></td></tr>
<tr class="separator:a108cb5fa1ed80fd8dab609581283010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893ab519917df67ea80a3d30aec95635"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a893ab519917df67ea80a3d30aec95635">printf</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a893ab519917df67ea80a3d30aec95635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a formatted string into this item at its current write position.  <a href="#a893ab519917df67ea80a3d30aec95635">More...</a><br /></td></tr>
<tr class="separator:a893ab519917df67ea80a3d30aec95635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b40b615a8109b07239becfa33040ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#ad1b40b615a8109b07239becfa33040ff">vprintf</a> (const char *fmt, va_list argp)</td></tr>
<tr class="memdesc:ad1b40b615a8109b07239becfa33040ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a formatted string into this item at its current write position.  <a href="#ad1b40b615a8109b07239becfa33040ff">More...</a><br /></td></tr>
<tr class="separator:ad1b40b615a8109b07239becfa33040ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9d2075bc9a13d6a19fe7d81a06042f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a0c9d2075bc9a13d6a19fe7d81a06042f">printf</a> (size_t off, const char *fmt,...)</td></tr>
<tr class="memdesc:a0c9d2075bc9a13d6a19fe7d81a06042f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a formatted string into this item at a selected position.  <a href="#a0c9d2075bc9a13d6a19fe7d81a06042f">More...</a><br /></td></tr>
<tr class="separator:a0c9d2075bc9a13d6a19fe7d81a06042f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0af3b0f7f13a40da14ea9cf10adb25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a0e0af3b0f7f13a40da14ea9cf10adb25">vprintf</a> (size_t off, const char *fmt, va_list argp)</td></tr>
<tr class="memdesc:a0e0af3b0f7f13a40da14ea9cf10adb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a formatted string into this item at a selected position.  <a href="#a0e0af3b0f7f13a40da14ea9cf10adb25">More...</a><br /></td></tr>
<tr class="separator:a0e0af3b0f7f13a40da14ea9cf10adb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efccaf791f519033681a23cbce1ed0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a8efccaf791f519033681a23cbce1ed0a">first</a> (void)</td></tr>
<tr class="memdesc:a8efccaf791f519033681a23cbce1ed0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the first item in the linked list of items.  <a href="#a8efccaf791f519033681a23cbce1ed0a">More...</a><br /></td></tr>
<tr class="separator:a8efccaf791f519033681a23cbce1ed0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa1e6bdd9019370b253029f5c09c802"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#aeaa1e6bdd9019370b253029f5c09c802">last</a> (void)</td></tr>
<tr class="memdesc:aeaa1e6bdd9019370b253029f5c09c802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the last item in the linked list of items.  <a href="#aeaa1e6bdd9019370b253029f5c09c802">More...</a><br /></td></tr>
<tr class="separator:aeaa1e6bdd9019370b253029f5c09c802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8615aa9e620aac3ece8c2512b6c25c5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a8615aa9e620aac3ece8c2512b6c25c5c">next</a> (void)</td></tr>
<tr class="memdesc:a8615aa9e620aac3ece8c2512b6c25c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the next item in the linked list of items.  <a href="#a8615aa9e620aac3ece8c2512b6c25c5c">More...</a><br /></td></tr>
<tr class="separator:a8615aa9e620aac3ece8c2512b6c25c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a7fb46a46fb9205e1d653502e07c7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#ad8a7fb46a46fb9205e1d653502e07c7f">prev</a> (void)</td></tr>
<tr class="memdesc:ad8a7fb46a46fb9205e1d653502e07c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the previous item in the linked list of items.  <a href="#ad8a7fb46a46fb9205e1d653502e07c7f">More...</a><br /></td></tr>
<tr class="separator:ad8a7fb46a46fb9205e1d653502e07c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ad481c8956678a122c39f921767440"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a20ad481c8956678a122c39f921767440">first</a> (void) const </td></tr>
<tr class="memdesc:a20ad481c8956678a122c39f921767440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a read-only pointer to the first item in the linked list of items.  <a href="#a20ad481c8956678a122c39f921767440">More...</a><br /></td></tr>
<tr class="separator:a20ad481c8956678a122c39f921767440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bf2eee3c0d66319ef48afd40a48cf6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#a04bf2eee3c0d66319ef48afd40a48cf6">last</a> (void) const </td></tr>
<tr class="memdesc:a04bf2eee3c0d66319ef48afd40a48cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a read-only pointer to the last item in the linked list of items.  <a href="#a04bf2eee3c0d66319ef48afd40a48cf6">More...</a><br /></td></tr>
<tr class="separator:a04bf2eee3c0d66319ef48afd40a48cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc44d9a735a4feac2376d610463a89f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#aabc44d9a735a4feac2376d610463a89f">next</a> (void) const </td></tr>
<tr class="memdesc:aabc44d9a735a4feac2376d610463a89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a read-only pointer to the next item in the linked list of items.  <a href="#aabc44d9a735a4feac2376d610463a89f">More...</a><br /></td></tr>
<tr class="separator:aabc44d9a735a4feac2376d610463a89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65e9545a8d9cdabd71abd3050bf5d6c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_writer_item.html#aa65e9545a8d9cdabd71abd3050bf5d6c">prev</a> (void) const </td></tr>
<tr class="memdesc:aa65e9545a8d9cdabd71abd3050bf5d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a read-only pointer to the previous item in the linked list of items.  <a href="#aa65e9545a8d9cdabd71abd3050bf5d6c">More...</a><br /></td></tr>
<tr class="separator:aa65e9545a8d9cdabd71abd3050bf5d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_a_q_item"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_a_q_item')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_a_q_item.html">AQItem</a></td></tr>
<tr class="memitem:a7824b9fc9bdc6e3b84817739106ee2a3 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a7824b9fc9bdc6e3b84817739106ee2a3">AQItem</a> (void)</td></tr>
<tr class="memdesc:a7824b9fc9bdc6e3b84817739106ee2a3 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new item with no initial allocation.  <a href="#a7824b9fc9bdc6e3b84817739106ee2a3">More...</a><br /></td></tr>
<tr class="separator:a7824b9fc9bdc6e3b84817739106ee2a3 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f5c3ef3f493c5c6df7a2dd4cc0d4b5 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a97f5c3ef3f493c5c6df7a2dd4cc0d4b5">AQItem</a> (const <a class="el" href="class_a_q_item.html">AQItem</a> &amp;other)</td></tr>
<tr class="memdesc:a97f5c3ef3f493c5c6df7a2dd4cc0d4b5 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new item so that it is an exact copy of another item.  <a href="#a97f5c3ef3f493c5c6df7a2dd4cc0d4b5">More...</a><br /></td></tr>
<tr class="separator:a97f5c3ef3f493c5c6df7a2dd4cc0d4b5 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780c92d7ed552d69ac2a692d09ca3a2b inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_q_item.html">AQItem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a780c92d7ed552d69ac2a692d09ca3a2b">operator=</a> (const <a class="el" href="class_a_q_item.html">AQItem</a> &amp;other)</td></tr>
<tr class="memdesc:a780c92d7ed552d69ac2a692d09ca3a2b inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns this item so that it is an exact copy of another item.  <a href="#a780c92d7ed552d69ac2a692d09ca3a2b">More...</a><br /></td></tr>
<tr class="separator:a780c92d7ed552d69ac2a692d09ca3a2b inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffbf9fdd69c76a971886033d46e8bc9 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#acffbf9fdd69c76a971886033d46e8bc9">~AQItem</a> (void)</td></tr>
<tr class="memdesc:acffbf9fdd69c76a971886033d46e8bc9 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this item.  <a href="#acffbf9fdd69c76a971886033d46e8bc9">More...</a><br /></td></tr>
<tr class="separator:acffbf9fdd69c76a971886033d46e8bc9 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae169220dd19f29c74d891935d2d9d4b8 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#ae169220dd19f29c74d891935d2d9d4b8">clear</a> (void)</td></tr>
<tr class="memdesc:ae169220dd19f29c74d891935d2d9d4b8 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content of this item so that it is no longer allocated.  <a href="#ae169220dd19f29c74d891935d2d9d4b8">More...</a><br /></td></tr>
<tr class="separator:ae169220dd19f29c74d891935d2d9d4b8 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21513e2a0208dbbd000c1821913ff595 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a21513e2a0208dbbd000c1821913ff595">isAllocated</a> (void) const </td></tr>
<tr class="memdesc:a21513e2a0208dbbd000c1821913ff595 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determins if this item has been allocated to part of a queue.  <a href="#a21513e2a0208dbbd000c1821913ff595">More...</a><br /></td></tr>
<tr class="separator:a21513e2a0208dbbd000c1821913ff595 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33029e27ef81601694a987648cd09f67 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67">queueIdentifier</a> (void) const </td></tr>
<tr class="memdesc:a33029e27ef81601694a987648cd09f67 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the unique queue identifier for this item.  <a href="#a33029e27ef81601694a987648cd09f67">More...</a><br /></td></tr>
<tr class="separator:a33029e27ef81601694a987648cd09f67 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2e1414d09863cf3b733119a068dbb8 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a8e2e1414d09863cf3b733119a068dbb8">linkIdentifier</a> (void) const </td></tr>
<tr class="memdesc:a8e2e1414d09863cf3b733119a068dbb8 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the link identifier for this item.  <a href="#a8e2e1414d09863cf3b733119a068dbb8">More...</a><br /></td></tr>
<tr class="separator:a8e2e1414d09863cf3b733119a068dbb8 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f66df9383cbeec05990270d2517397 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a09f66df9383cbeec05990270d2517397">isCommitted</a> (void) const </td></tr>
<tr class="memdesc:a09f66df9383cbeec05990270d2517397 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this item was committed to the queue with a call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>.  <a href="#a09f66df9383cbeec05990270d2517397">More...</a><br /></td></tr>
<tr class="separator:a09f66df9383cbeec05990270d2517397 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3eb62c6b4c6dee0c2afafafd8bea06f inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#ac3eb62c6b4c6dee0c2afafafd8bea06f">isReleased</a> (void) const </td></tr>
<tr class="memdesc:ac3eb62c6b4c6dee0c2afafafd8bea06f inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this item has been released from the queue with a call to <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">AQReader::release()</a>.  <a href="#ac3eb62c6b4c6dee0c2afafafd8bea06f">More...</a><br /></td></tr>
<tr class="separator:ac3eb62c6b4c6dee0c2afafafd8bea06f inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2313675d412d90c4b54da718dbd487fc inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a2313675d412d90c4b54da718dbd487fc">isChecksumValid</a> (void) const </td></tr>
<tr class="memdesc:a2313675d412d90c4b54da718dbd487fc inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determies if the checksum for this item is valid when <a class="el" href="class_a_q.html#ae5926cd2aa448ec7963d49c91fe0b0aa" title="When formatting a queue set this flag to enable CRC-32 checksum calculation and validation over each ...">AQ::OPTION_CRC32</a> is set for this queue.  <a href="#a2313675d412d90c4b54da718dbd487fc">More...</a><br /></td></tr>
<tr class="separator:a2313675d412d90c4b54da718dbd487fc inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba43b837efe456e423cf290b7bdae608 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#aba43b837efe456e423cf290b7bdae608">capacity</a> (void) const </td></tr>
<tr class="memdesc:aba43b837efe456e423cf290b7bdae608 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the total number of bytes that can be stored in this item.  <a href="#aba43b837efe456e423cf290b7bdae608">More...</a><br /></td></tr>
<tr class="separator:aba43b837efe456e423cf290b7bdae608 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346237d15617f812d325c173f21892b9 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9">size</a> (void) const </td></tr>
<tr class="memdesc:a346237d15617f812d325c173f21892b9 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the total number of bytes that have been stored by the user into this item.  <a href="#a346237d15617f812d325c173f21892b9">More...</a><br /></td></tr>
<tr class="separator:a346237d15617f812d325c173f21892b9 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395900d5781030372dfc231d2361d41c inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">const unsigned char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a395900d5781030372dfc231d2361d41c">operator[]</a> (size_t idx) const </td></tr>
<tr class="memdesc:a395900d5781030372dfc231d2361d41c inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a reference to one of the bytes within this item.  <a href="#a395900d5781030372dfc231d2361d41c">More...</a><br /></td></tr>
<tr class="separator:a395900d5781030372dfc231d2361d41c inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab109099474cb358ce7b2cd0cbbf4a530 inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_item.html">AQItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#ab109099474cb358ce7b2cd0cbbf4a530">first</a> (void) const </td></tr>
<tr class="memdesc:ab109099474cb358ce7b2cd0cbbf4a530 inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the first item in the linked list of items.  <a href="#ab109099474cb358ce7b2cd0cbbf4a530">More...</a><br /></td></tr>
<tr class="separator:ab109099474cb358ce7b2cd0cbbf4a530 inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b8a01fb113490f2c96bf9a7cf60e8c inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_item.html">AQItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a71b8a01fb113490f2c96bf9a7cf60e8c">last</a> (void) const </td></tr>
<tr class="memdesc:a71b8a01fb113490f2c96bf9a7cf60e8c inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the last item in the linked list of items.  <a href="#a71b8a01fb113490f2c96bf9a7cf60e8c">More...</a><br /></td></tr>
<tr class="separator:a71b8a01fb113490f2c96bf9a7cf60e8c inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852962115eaa0b0bd8d356a682778afe inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_item.html">AQItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a852962115eaa0b0bd8d356a682778afe">next</a> (void) const </td></tr>
<tr class="memdesc:a852962115eaa0b0bd8d356a682778afe inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the next item in the linked list of items.  <a href="#a852962115eaa0b0bd8d356a682778afe">More...</a><br /></td></tr>
<tr class="separator:a852962115eaa0b0bd8d356a682778afe inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afdc65d0570f2ee4bac6c3d61c2e16f inherit pub_methods_class_a_q_item"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_item.html">AQItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a5afdc65d0570f2ee4bac6c3d61c2e16f">prev</a> (void) const </td></tr>
<tr class="memdesc:a5afdc65d0570f2ee4bac6c3d61c2e16f inherit pub_methods_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the previous item in the linked list of items.  <a href="#a5afdc65d0570f2ee4bac6c3d61c2e16f">More...</a><br /></td></tr>
<tr class="separator:a5afdc65d0570f2ee4bac6c3d61c2e16f inherit pub_methods_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_class_a_q_item"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_a_q_item')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_a_q_item.html">AQItem</a></td></tr>
<tr class="memitem:aaa5f97ad56a729c0ae1e8687111a9a40 inherit pub_static_attribs_class_a_q_item"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#aaa5f97ad56a729c0ae1e8687111a9a40">QUEUE_IDENTIFIER_MASK</a> = 0x1FFFFFFF</td></tr>
<tr class="memdesc:aaa5f97ad56a729c0ae1e8687111a9a40 inherit pub_static_attribs_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a> will always return a value that fits within this bitmask.  <a href="#aaa5f97ad56a729c0ae1e8687111a9a40">More...</a><br /></td></tr>
<tr class="separator:aaa5f97ad56a729c0ae1e8687111a9a40 inherit pub_static_attribs_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535cc166babbb9927ed075dc08eddaba inherit pub_static_attribs_class_a_q_item"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a535cc166babbb9927ed075dc08eddaba">QUEUE_IDENTIFIER_USER_MASK</a> = 0xE0000000</td></tr>
<tr class="memdesc:a535cc166babbb9927ed075dc08eddaba inherit pub_static_attribs_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a> will always have the bits in this mask set to 0.  <a href="#a535cc166babbb9927ed075dc08eddaba">More...</a><br /></td></tr>
<tr class="separator:a535cc166babbb9927ed075dc08eddaba inherit pub_static_attribs_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a0322677680ab691ff049dc69a2aa1 inherit pub_static_attribs_class_a_q_item"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a53a0322677680ab691ff049dc69a2aa1">QUEUE_IDENTIFIER_USER_BIT</a> = 29</td></tr>
<tr class="memdesc:a53a0322677680ab691ff049dc69a2aa1 inherit pub_static_attribs_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first unused bit in the <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a>.  <a href="#a53a0322677680ab691ff049dc69a2aa1">More...</a><br /></td></tr>
<tr class="separator:a53a0322677680ab691ff049dc69a2aa1 inherit pub_static_attribs_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987fe89fa76ce1733f1f8146873aead8 inherit pub_static_attribs_class_a_q_item"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a987fe89fa76ce1733f1f8146873aead8">QUEUE_IDENTIFIER_INVALID</a> = 0xFFFFFFFF</td></tr>
<tr class="memdesc:a987fe89fa76ce1733f1f8146873aead8 inherit pub_static_attribs_class_a_q_item"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a queue identifier is not known or has not been allocated this value will be stored in <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a> or <a class="el" href="class_a_q_item.html#a8e2e1414d09863cf3b733119a068dbb8" title="Obtains the link identifier for this item. ">AQItem::linkIdentifier()</a>.  <a href="#a987fe89fa76ce1733f1f8146873aead8">More...</a><br /></td></tr>
<tr class="separator:a987fe89fa76ce1733f1f8146873aead8 inherit pub_static_attribs_class_a_q_item"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates an item is being written to a Multi-Producer Concurrent Allocating Queue. </p>
<p>The <a class="el" href="class_a_q_writer_item.html" title="Encapsulates an item is being written to a Multi-Producer Concurrent Allocating Queue. ">AQWriterItem</a> can be either accessed directly and written with, e.g., memcpy() or alternatly it can be written to using the <a class="el" href="class_a_q_writer_item.html#a06d5dcc6535fbbc3f06bc2a56ed2ae18" title="Writes data into this item at its current write position. ">write(const void *, size_t)</a> or similar functions. When the <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> option has been set the <a class="el" href="class_a_q_writer_item.html#a06d5dcc6535fbbc3f06bc2a56ed2ae18" title="Writes data into this item at its current write position. ">write(const void *, size_t)</a> functions are the main mechanism for extending the length of the item by appending new items to the end of the linked list. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afdcdefe235f169332e99ea46160f4445"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AQWriterItem::AQWriterItem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new item with no initial allocation. </p>

</div>
</div>
<a class="anchor" id="afb89ea3ad90a751066342f136fe4b2fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AQWriterItem::AQWriterItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new item so that it is an exact copy of another item. </p>
<p>Note that this does not create a new entry in the queue - it just copies the references from the other item. Regardless of how many copies are made only a single call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a> may be made. Accessing the memory of an item that has been committed elsewhere results in undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other item to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf6599e6e588dacf5cc51974a0caeea7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AQWriterItem::~AQWriterItem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this item. </p>
<p>This will not take any action on the underlying queue such as calling <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a> or <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">AQReader::release()</a>. It is entirely up to the application to ensure that each item that must be committed or released has the appropriate action taken. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8efccaf791f519033681a23cbce1ed0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_q_writer_item.html">AQWriterItem</a>* AQWriterItem::first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a pointer to the first item in the linked list of items. </p>
<p>The returned pointer is always identical to this unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> has been set for the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>The first item. This is never NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a20ad481c8956678a122c39f921767440"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a>* AQWriterItem::first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a read-only pointer to the first item in the linked list of items. </p>
<p>The returned pointer is always identical to this unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> has been set for the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>The first item. This is never NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="aeaa1e6bdd9019370b253029f5c09c802"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_q_writer_item.html">AQWriterItem</a>* AQWriterItem::last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a pointer to the last item in the linked list of items. </p>
<p>The returned pointer is always identical to this unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> has been set for the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>The last item. This is never NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a04bf2eee3c0d66319ef48afd40a48cf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a>* AQWriterItem::last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a read-only pointer to the last item in the linked list of items. </p>
<p>The returned pointer is always identical to this unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> has been set for the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>The last item. This is never NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a8615aa9e620aac3ece8c2512b6c25c5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_q_writer_item.html">AQWriterItem</a>* AQWriterItem::next </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a pointer to the next item in the linked list of items. </p>
<p>If this is the last item in the list then NULL is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The next item or NULL if there are no further items. NULL is always returned unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="aabc44d9a735a4feac2376d610463a89f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a>* AQWriterItem::next </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a read-only pointer to the next item in the linked list of items. </p>
<p>If this is the last item in the list then NULL is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The next item or NULL if there are no further items. NULL is always returned unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="a626754df58bf7442942ffcde296aac36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_q_writer_item.html">AQWriterItem</a>&amp; AQWriterItem::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns this item so that it is an exact copy of another item. </p>
<p>Note that this does not create a new entry in the queue - it just copies the references from the other item. Regardless of how many copies are made only a single call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a> may be made. Accessing the memory of an item that has been committed elsewhere results in undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other item to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a class="anchor" id="ab025ce2d8f8ec5716b97a6d8cfd6056a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char&amp; AQWriterItem::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a reference to one of the bytes within this item. </p>
<p>This reference is only to be used for reading; writing the byte results in undefined behavior. The bytes in this item are allocated contiguously which means applications can do: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr = &amp;item[0];</div></div><!-- fragment --><p> In order to obtain a pointer to the underlying array.</p>
<p>No bounds checking is performed on access via this operator. As such the caller must ensure that idx is in the range 0 to (<a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> - 1) inclusive. The effect of accessing a byte outside of this range, even through the pointer taken in the example above, is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the byte to retreive. Must be in the range of 0 to (<a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> - 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the specified byte. If this item is not allocated or the provided index is outside the range of bytes in this item then the returned value is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b1cf82c67ef0f1aa6a52786124d2d64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char&amp; AQWriterItem::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a reference to one of the bytes within this item. </p>
<p>This reference can be used for both reading and writing. The bytes in this item are allocated contiguously which means applications can do: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr = &amp;item[0];</div></div><!-- fragment --><p> In order to obtain a pointer to the underlying array.</p>
<p>No bounds checking is performed on access via this operator. As such the caller must ensure that idx is in the range 0 to (<a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> - 1) inclusive. The effect of accessing a byte outside of this range, even through the pointer taken in the example above, is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the byte to retreive. Must be in the range of 0 to (<a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> - 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-write reference to the specified byte. If this item is not allocated or the provided index is outside the range of bytes in this item then the returned value is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8a7fb46a46fb9205e1d653502e07c7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_q_writer_item.html">AQWriterItem</a>* AQWriterItem::prev </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a pointer to the previous item in the linked list of items. </p>
<p>If this is the first item in the list then NULL is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The previous item or NULL if there are no further items. NULL is always returned unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="aa65e9545a8d9cdabd71abd3050bf5d6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_q_writer_item.html">AQWriterItem</a>* AQWriterItem::prev </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a read-only pointer to the previous item in the linked list of items. </p>
<p>If this is the first item in the list then NULL is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The previous item or NULL if there are no further items. NULL is always returned unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="a893ab519917df67ea80a3d30aec95635"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AQWriterItem::printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a formatted string into this item at its current write position. </p>
<p>The write position is incremented by the number of bytes actually written. If there is not enough space in the item then the print is truncated to the available space.</p>
<p>The string written into the item is not nul-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>The printf-style formatting string. </td></tr>
    <tr><td class="paramname">...</td><td>The printf-style formatting arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are two possibilities:<ul>
<li>The return value is non-negative (&gt;= 0). In this case the string was fully written into the item and the total number of bytes consumed is returned.</li>
<li>The return value is negative (&lt; 0). In this case it was not possible to fully write the string into the item, nor was it possible to allocate further items to the list if the queue is in <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> mode. Only part of the string has been written. The length of the partially written string can be obtained by applying the binary 1's-complement operator (~) to the returned value. </li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If this item was not populated by a successful call to <a class="el" href="class_a_q_writer.html#ae0e2eeac326abd648b6aa60a1fb5315a" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> or if it has been committed with a call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the fmt argument was NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c9d2075bc9a13d6a19fe7d81a06042f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AQWriterItem::printf </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a formatted string into this item at a selected position. </p>
<p>If the write succeeds then the write position as used by write(const void *, size_t, InsufficientSpaceAction) is set to the maximum of its current value and off + memSize. If there is not enough space in the item then the print is truncated to the available space.</p>
<p>The string written into the item is not nul-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>The offset from this item where the write is to be performed. For <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> items this offset may be larger than the <a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> of this item in which case it finds the item that contains that offset and starts the write there. </td></tr>
    <tr><td class="paramname">fmt</td><td>The printf-style formatting string. </td></tr>
    <tr><td class="paramname">...</td><td>The printf-style formatting arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are two possibilities:<ul>
<li>The return value is non-negative (&gt;= 0). In this case the string was fully written into the item and the total number of bytes consumed is returned.</li>
<li>The return value is negative (&lt; 0). In this case it was not possible to fully write the string into the item, nor was it possible to allocate further items to the list if the queue is in <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> mode. Only part of the string has been written. The length of the partially written string can be obtained by applying the binary 1's-complement operator (~) to the returned value. </li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If this item was not populated by a successful call to <a class="el" href="class_a_q_writer.html#ae0e2eeac326abd648b6aa60a1fb5315a" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> or if it has been committed with a call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the fmt argument was NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52f19448fb3ca5fd9e1afbeb7d60027a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AQWriterItem::setLinkIdentifier </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lkid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the link identifier for this item. </p>
<p>Setting the link identifier only makes sense when <a class="el" href="class_a_q.html#a8c1b45770a35b703df2b1f1f17ca4745" title="When formatting a queue set this flag to attach a link identifier to each item. ">AQ::OPTION_LINK_IDENTIFIER</a> has been set on the queue and <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is not set. In all other situations the link identifier set here will not propogate through to the item reader via <a class="el" href="class_a_q_reader.html#a6746d86b29c04ff19032106323cdef6f" title="Obtains the next item from the queue. ">AQReader::retrieve()</a>. See <a class="el" href="class_a_q_item.html#a8e2e1414d09863cf3b733119a068dbb8" title="Obtains the link identifier for this item. ">AQItem::linkIdentifier()</a> for more information on why this is the case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lkid</td><td>The link identifier value to set for this item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1b40b615a8109b07239becfa33040ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AQWriterItem::vprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>argp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a formatted string into this item at its current write position. </p>
<p>The write position is incremented by the number of bytes actually written. If there is not enough space in the item then the print is truncated to the available space.</p>
<p>The string written into the item is not nul-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>The printf-style formatting string. </td></tr>
    <tr><td class="paramname">argp</td><td>The printf-style formatting arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are two possibilities:<ul>
<li>The return value is non-negative (&gt;= 0). In this case the string was fully written into the item and the total number of bytes consumed is returned.</li>
<li>The return value is negative (&lt; 0). In this case it was not possible to fully write the string into the item, nor was it possible to allocate further items to the list if the queue is in <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> mode. Only part of the string has been written. The length of the partially written string can be obtained by applying the binary 1's-complement operator (~) to the returned value. </li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If this item was not populated by a successful call to <a class="el" href="class_a_q_writer.html#ae0e2eeac326abd648b6aa60a1fb5315a" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> or if it has been committed with a call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the fmt argument was NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e0af3b0f7f13a40da14ea9cf10adb25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AQWriterItem::vprintf </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>argp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a formatted string into this item at a selected position. </p>
<p>If the write succeeds then the write position as used by write(const void *, size_t, InsufficientSpaceAction) is set to the maximum of its current value and off + memSize. If there is not enough space in the item then the print is truncated to the available space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>The offset from this item where the write is to be performed. For <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> items this offset may be larger than the <a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> of this item in which case it finds the item that contains that offset and starts the write there. </td></tr>
    <tr><td class="paramname">fmt</td><td>The printf-style formatting string. </td></tr>
    <tr><td class="paramname">argp</td><td>The printf-style formatting arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are two possibilities:<ul>
<li>The return value is non-negative (&gt;= 0). In this case the string was fully written into the item and the total number of bytes consumed is returned.</li>
<li>The return value is negative (&lt; 0). In this case it was not possible to fully write the string into the item, nor was it possible to allocate further items to the list if the queue is in <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> mode. Only part of the string has been written. The length of the partially written string can be obtained by applying the binary 1's-complement operator (~) to the returned value. </li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If this item was not populated by a successful call to <a class="el" href="class_a_q_writer.html#ae0e2eeac326abd648b6aa60a1fb5315a" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> or if it has been committed with a call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the fmt argument was NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06d5dcc6535fbbc3f06bc2a56ed2ae18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AQWriterItem::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data into this item at its current write position. </p>
<p>The write position differs depending on whether <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> has been configured:</p><ul>
<li>When <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is not set then the item internaly tracks the highest index where no write operation has been performed. The write occurs at that index.</li>
<li>When <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is set then the write occurs at the very end of the item, essentially appending and possibly extending the size of the item by adding to the linked list. If the write succeeds then the write position is incremented by the number of bytes written. If this fails (an exception is thrown or more items could not be allocated) no changes are made to this item.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>The buffer that contains the memory to write into this item. </td></tr>
    <tr><td class="paramname">memSize</td><td>The number of bytes to write into this item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the write succeeded or false if the write failed because it was not possible to allocate another <a class="el" href="class_a_q_writer_item.html" title="Encapsulates an item is being written to a Multi-Producer Concurrent Allocating Queue. ">AQWriterItem</a> via <a class="el" href="class_a_q_writer.html#ae0e2eeac326abd648b6aa60a1fb5315a" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If this item was not populated by a successful call to <a class="el" href="class_a_q_writer.html#ae0e2eeac326abd648b6aa60a1fb5315a" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> or if it has been committed with a call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the mem argument was NULL and memSize was any value other than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a108cb5fa1ed80fd8dab609581283010d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AQWriterItem::write </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data into this item at a selected position. </p>
<p>If the write succeeds then the write position as used by <a class="el" href="class_a_q_writer_item.html#a06d5dcc6535fbbc3f06bc2a56ed2ae18" title="Writes data into this item at its current write position. ">write(const void *, size_t)</a> is set to the maximum of its current value and off + memSize. If the write fails (an exception is thrown or more items could not be allocated) no changes are made to this item.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>The offset from this item where the write is to be performed. For <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> items this offset may be larger than the <a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> of this item in which case it finds the item that contains that offset and starts the write there. </td></tr>
    <tr><td class="paramname">mem</td><td>The buffer that contains the memory to write into this item. </td></tr>
    <tr><td class="paramname">memSize</td><td>The number of bytes to write into this item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the write succeeded or false if the write failed because it was not possible to allocate another <a class="el" href="class_a_q_writer_item.html" title="Encapsulates an item is being written to a Multi-Producer Concurrent Allocating Queue. ">AQWriterItem</a> via <a class="el" href="class_a_q_writer.html#ae0e2eeac326abd648b6aa60a1fb5315a" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If this item was not populated by a successful call to <a class="el" href="class_a_q_writer.html#ae0e2eeac326abd648b6aa60a1fb5315a" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> or if it has been committed with a call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the mem argument was NULL and memSize was any value other than 0. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>If the queue does not have the <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> option set and the offest is at the end, or beyond the end, of the item. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>If the queue does not have the <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> option set and there is not enough space left in the queue to store the requested number of bytes at the given offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>AQWriterItem.h</li>
<li>AQWriterItem.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 10 2016 13:00:59 for AQ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
