<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AQ: AQItem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AQ
   &#160;<span id="projectnumber">0.0</span>
   </div>
   <div id="projectbrief">Multi-Producer Concurrent Allocating Queue</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_a_q_item-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AQItem Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates the memory for an item that resides with a Multi-Producer Concurrent Allocating Queue.  
 <a href="class_a_q_item.html#details">More...</a></p>

<p><code>#include &lt;AQItem.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AQItem:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_a_q_item.png" usemap="#AQItem_map" alt=""/>
  <map id="AQItem_map" name="AQItem_map">
<area href="class_a_q_writer_item.html" title="Encapsulates an item is being written to a Multi-Producer Concurrent Allocating Queue. " alt="AQWriterItem" shape="rect" coords="0,56,87,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7824b9fc9bdc6e3b84817739106ee2a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a7824b9fc9bdc6e3b84817739106ee2a3">AQItem</a> (void)</td></tr>
<tr class="memdesc:a7824b9fc9bdc6e3b84817739106ee2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new item with no initial allocation.  <a href="#a7824b9fc9bdc6e3b84817739106ee2a3">More...</a><br /></td></tr>
<tr class="separator:a7824b9fc9bdc6e3b84817739106ee2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f5c3ef3f493c5c6df7a2dd4cc0d4b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a97f5c3ef3f493c5c6df7a2dd4cc0d4b5">AQItem</a> (const <a class="el" href="class_a_q_item.html">AQItem</a> &amp;other)</td></tr>
<tr class="memdesc:a97f5c3ef3f493c5c6df7a2dd4cc0d4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new item so that it is an exact copy of another item.  <a href="#a97f5c3ef3f493c5c6df7a2dd4cc0d4b5">More...</a><br /></td></tr>
<tr class="separator:a97f5c3ef3f493c5c6df7a2dd4cc0d4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780c92d7ed552d69ac2a692d09ca3a2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_q_item.html">AQItem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a780c92d7ed552d69ac2a692d09ca3a2b">operator=</a> (const <a class="el" href="class_a_q_item.html">AQItem</a> &amp;other)</td></tr>
<tr class="memdesc:a780c92d7ed552d69ac2a692d09ca3a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns this item so that it is an exact copy of another item.  <a href="#a780c92d7ed552d69ac2a692d09ca3a2b">More...</a><br /></td></tr>
<tr class="separator:a780c92d7ed552d69ac2a692d09ca3a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffbf9fdd69c76a971886033d46e8bc9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#acffbf9fdd69c76a971886033d46e8bc9">~AQItem</a> (void)</td></tr>
<tr class="memdesc:acffbf9fdd69c76a971886033d46e8bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this item.  <a href="#acffbf9fdd69c76a971886033d46e8bc9">More...</a><br /></td></tr>
<tr class="separator:acffbf9fdd69c76a971886033d46e8bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae169220dd19f29c74d891935d2d9d4b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#ae169220dd19f29c74d891935d2d9d4b8">clear</a> (void)</td></tr>
<tr class="memdesc:ae169220dd19f29c74d891935d2d9d4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content of this item so that it is no longer allocated.  <a href="#ae169220dd19f29c74d891935d2d9d4b8">More...</a><br /></td></tr>
<tr class="separator:ae169220dd19f29c74d891935d2d9d4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21513e2a0208dbbd000c1821913ff595"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a21513e2a0208dbbd000c1821913ff595">isAllocated</a> (void) const </td></tr>
<tr class="memdesc:a21513e2a0208dbbd000c1821913ff595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determins if this item has been allocated to part of a queue.  <a href="#a21513e2a0208dbbd000c1821913ff595">More...</a><br /></td></tr>
<tr class="separator:a21513e2a0208dbbd000c1821913ff595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33029e27ef81601694a987648cd09f67"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67">queueIdentifier</a> (void) const </td></tr>
<tr class="memdesc:a33029e27ef81601694a987648cd09f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the unique queue identifier for this item.  <a href="#a33029e27ef81601694a987648cd09f67">More...</a><br /></td></tr>
<tr class="separator:a33029e27ef81601694a987648cd09f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2e1414d09863cf3b733119a068dbb8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a8e2e1414d09863cf3b733119a068dbb8">linkIdentifier</a> (void) const </td></tr>
<tr class="memdesc:a8e2e1414d09863cf3b733119a068dbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the link identifier for this item.  <a href="#a8e2e1414d09863cf3b733119a068dbb8">More...</a><br /></td></tr>
<tr class="separator:a8e2e1414d09863cf3b733119a068dbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f66df9383cbeec05990270d2517397"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a09f66df9383cbeec05990270d2517397">isCommitted</a> (void) const </td></tr>
<tr class="memdesc:a09f66df9383cbeec05990270d2517397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this item was committed to the queue with a call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>.  <a href="#a09f66df9383cbeec05990270d2517397">More...</a><br /></td></tr>
<tr class="separator:a09f66df9383cbeec05990270d2517397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3eb62c6b4c6dee0c2afafafd8bea06f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#ac3eb62c6b4c6dee0c2afafafd8bea06f">isReleased</a> (void) const </td></tr>
<tr class="memdesc:ac3eb62c6b4c6dee0c2afafafd8bea06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this item has been released from the queue with a call to <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">AQReader::release()</a>.  <a href="#ac3eb62c6b4c6dee0c2afafafd8bea06f">More...</a><br /></td></tr>
<tr class="separator:ac3eb62c6b4c6dee0c2afafafd8bea06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2313675d412d90c4b54da718dbd487fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a2313675d412d90c4b54da718dbd487fc">isChecksumValid</a> (void) const </td></tr>
<tr class="memdesc:a2313675d412d90c4b54da718dbd487fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determies if the checksum for this item is valid when <a class="el" href="class_a_q.html#ae5926cd2aa448ec7963d49c91fe0b0aa" title="When formatting a queue set this flag to enable CRC-32 checksum calculation and validation over each ...">AQ::OPTION_CRC32</a> is set for this queue.  <a href="#a2313675d412d90c4b54da718dbd487fc">More...</a><br /></td></tr>
<tr class="separator:a2313675d412d90c4b54da718dbd487fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba43b837efe456e423cf290b7bdae608"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#aba43b837efe456e423cf290b7bdae608">capacity</a> (void) const </td></tr>
<tr class="memdesc:aba43b837efe456e423cf290b7bdae608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the total number of bytes that can be stored in this item.  <a href="#aba43b837efe456e423cf290b7bdae608">More...</a><br /></td></tr>
<tr class="separator:aba43b837efe456e423cf290b7bdae608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346237d15617f812d325c173f21892b9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9">size</a> (void) const </td></tr>
<tr class="memdesc:a346237d15617f812d325c173f21892b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the total number of bytes that have been stored by the user into this item.  <a href="#a346237d15617f812d325c173f21892b9">More...</a><br /></td></tr>
<tr class="separator:a346237d15617f812d325c173f21892b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395900d5781030372dfc231d2361d41c"><td class="memItemLeft" align="right" valign="top">const unsigned char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a395900d5781030372dfc231d2361d41c">operator[]</a> (size_t idx) const </td></tr>
<tr class="memdesc:a395900d5781030372dfc231d2361d41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a reference to one of the bytes within this item.  <a href="#a395900d5781030372dfc231d2361d41c">More...</a><br /></td></tr>
<tr class="separator:a395900d5781030372dfc231d2361d41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab109099474cb358ce7b2cd0cbbf4a530"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_item.html">AQItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#ab109099474cb358ce7b2cd0cbbf4a530">first</a> (void) const </td></tr>
<tr class="memdesc:ab109099474cb358ce7b2cd0cbbf4a530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the first item in the linked list of items.  <a href="#ab109099474cb358ce7b2cd0cbbf4a530">More...</a><br /></td></tr>
<tr class="separator:ab109099474cb358ce7b2cd0cbbf4a530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b8a01fb113490f2c96bf9a7cf60e8c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_item.html">AQItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a71b8a01fb113490f2c96bf9a7cf60e8c">last</a> (void) const </td></tr>
<tr class="memdesc:a71b8a01fb113490f2c96bf9a7cf60e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the last item in the linked list of items.  <a href="#a71b8a01fb113490f2c96bf9a7cf60e8c">More...</a><br /></td></tr>
<tr class="separator:a71b8a01fb113490f2c96bf9a7cf60e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852962115eaa0b0bd8d356a682778afe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_item.html">AQItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a852962115eaa0b0bd8d356a682778afe">next</a> (void) const </td></tr>
<tr class="memdesc:a852962115eaa0b0bd8d356a682778afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the next item in the linked list of items.  <a href="#a852962115eaa0b0bd8d356a682778afe">More...</a><br /></td></tr>
<tr class="separator:a852962115eaa0b0bd8d356a682778afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afdc65d0570f2ee4bac6c3d61c2e16f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_q_item.html">AQItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a5afdc65d0570f2ee4bac6c3d61c2e16f">prev</a> (void) const </td></tr>
<tr class="memdesc:a5afdc65d0570f2ee4bac6c3d61c2e16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the previous item in the linked list of items.  <a href="#a5afdc65d0570f2ee4bac6c3d61c2e16f">More...</a><br /></td></tr>
<tr class="separator:a5afdc65d0570f2ee4bac6c3d61c2e16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aaa5f97ad56a729c0ae1e8687111a9a40"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#aaa5f97ad56a729c0ae1e8687111a9a40">QUEUE_IDENTIFIER_MASK</a> = 0x1FFFFFFF</td></tr>
<tr class="memdesc:aaa5f97ad56a729c0ae1e8687111a9a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a> will always return a value that fits within this bitmask.  <a href="#aaa5f97ad56a729c0ae1e8687111a9a40">More...</a><br /></td></tr>
<tr class="separator:aaa5f97ad56a729c0ae1e8687111a9a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535cc166babbb9927ed075dc08eddaba"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a535cc166babbb9927ed075dc08eddaba">QUEUE_IDENTIFIER_USER_MASK</a> = 0xE0000000</td></tr>
<tr class="memdesc:a535cc166babbb9927ed075dc08eddaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a> will always have the bits in this mask set to 0.  <a href="#a535cc166babbb9927ed075dc08eddaba">More...</a><br /></td></tr>
<tr class="separator:a535cc166babbb9927ed075dc08eddaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a0322677680ab691ff049dc69a2aa1"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a53a0322677680ab691ff049dc69a2aa1">QUEUE_IDENTIFIER_USER_BIT</a> = 29</td></tr>
<tr class="memdesc:a53a0322677680ab691ff049dc69a2aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first unused bit in the <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a>.  <a href="#a53a0322677680ab691ff049dc69a2aa1">More...</a><br /></td></tr>
<tr class="separator:a53a0322677680ab691ff049dc69a2aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987fe89fa76ce1733f1f8146873aead8"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_q_item.html#a987fe89fa76ce1733f1f8146873aead8">QUEUE_IDENTIFIER_INVALID</a> = 0xFFFFFFFF</td></tr>
<tr class="memdesc:a987fe89fa76ce1733f1f8146873aead8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a queue identifier is not known or has not been allocated this value will be stored in <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a> or <a class="el" href="class_a_q_item.html#a8e2e1414d09863cf3b733119a068dbb8" title="Obtains the link identifier for this item. ">AQItem::linkIdentifier()</a>.  <a href="#a987fe89fa76ce1733f1f8146873aead8">More...</a><br /></td></tr>
<tr class="separator:a987fe89fa76ce1733f1f8146873aead8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates the memory for an item that resides with a Multi-Producer Concurrent Allocating Queue. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7824b9fc9bdc6e3b84817739106ee2a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AQItem::AQItem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new item with no initial allocation. </p>

</div>
</div>
<a class="anchor" id="a97f5c3ef3f493c5c6df7a2dd4cc0d4b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AQItem::AQItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_q_item.html">AQItem</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new item so that it is an exact copy of another item. </p>
<p>Note that this does not create a new entry in the queue - it just copies the references from the other item. Regardless of how many copies are made only a single call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a> or <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">AQReader::release()</a> may be made. Accessing the memory of an item that has been committed or released elsewhere results in undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other item to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acffbf9fdd69c76a971886033d46e8bc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AQItem::~AQItem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this item. </p>
<p>This will not take any action on the underlying queue such as calling <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a> or <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">AQReader::release()</a>. It is entirely up to the application to ensure that each item that must be committed or released has the appropriate action taken. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aba43b837efe456e423cf290b7bdae608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t AQItem::capacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the total number of bytes that can be stored in this item. </p>
<p>This only ever refers to this particular item - when <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is set each individual <a class="el" href="class_a_q_item.html" title="Encapsulates the memory for an item that resides with a Multi-Producer Concurrent Allocating Queue...">AQItem</a> in the linked list has its own capacity value.</p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of this item in bytes. If this item is not allocated the returned value is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="ae169220dd19f29c74d891935d2d9d4b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AQItem::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the content of this item so that it is no longer allocated. </p>
<p><a class="el" href="class_a_q_item.html#a21513e2a0208dbbd000c1821913ff595" title="Determins if this item has been allocated to part of a queue. ">AQItem::isAllocated()</a> now returns false. When this item is the first entry in a linked list this has the effect of deleting all the other links in the list such that <a class="el" href="class_a_q_item.html#a852962115eaa0b0bd8d356a682778afe" title="Obtains a pointer to the next item in the linked list of items. ">AQItem::next()</a> now returns NULL. When this item is part of a linked list, but no the first item, it just clears the state of this item without impacting the list itself. </p>

</div>
</div>
<a class="anchor" id="ab109099474cb358ce7b2cd0cbbf4a530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_q_item.html">AQItem</a>* AQItem::first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a pointer to the first item in the linked list of items. </p>
<p>The returned pointer is always identical to this unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> has been set for the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>The first item. This is never NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a21513e2a0208dbbd000c1821913ff595"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AQItem::isAllocated </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determins if this item has been allocated to part of a queue. </p>
<p>This only returns true if there is a backing item within the queue that has provided memory that can be read (and written in the case of <a class="el" href="class_a_q_writer_item.html" title="Encapsulates an item is being written to a Multi-Producer Concurrent Allocating Queue. ">AQWriterItem</a>). </p><dl class="section return"><dt>Returns</dt><dd>True if this item has been allocated, false if it has not been allocated. Note that after <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a> and <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">AQReader::release()</a> are called the items passed to those functions are automatically deallocated. </dd></dl>

</div>
</div>
<a class="anchor" id="a2313675d412d90c4b54da718dbd487fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AQItem::isChecksumValid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determies if the checksum for this item is valid when <a class="el" href="class_a_q.html#ae5926cd2aa448ec7963d49c91fe0b0aa" title="When formatting a queue set this flag to enable CRC-32 checksum calculation and validation over each ...">AQ::OPTION_CRC32</a> is set for this queue. </p>
<p>When <a class="el" href="class_a_q.html#ae5926cd2aa448ec7963d49c91fe0b0aa" title="When formatting a queue set this flag to enable CRC-32 checksum calculation and validation over each ...">AQ::OPTION_CRC32</a> is not set then this always return true.</p>
<p>Note that in the case of queues with the <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> format option set if any one of the items had an invalid checksum then all the items in the linked are maked as with invalid checksums.</p>
<dl class="section return"><dt>Returns</dt><dd>False if <a class="el" href="class_a_q.html#ae5926cd2aa448ec7963d49c91fe0b0aa" title="When formatting a queue set this flag to enable CRC-32 checksum calculation and validation over each ...">AQ::OPTION_CRC32</a> is enabled and the checksum calculated did not match the one stored in the. Returns true in all other cases except where this item is not allocated in which case the returned value is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a09f66df9383cbeec05990270d2517397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AQItem::isCommitted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this item was committed to the queue with a call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>. </p>
<p>There are a number of situations to consider when inspecting this value:</p><ul>
<li>For items claimed by calling <a class="el" href="class_a_q_writer.html#ae0e2eeac326abd648b6aa60a1fb5315a" title="Claims an item to be stored in the queue. ">AQWriter::claim()</a> this always returns false.</li>
<li>When an item is retrieved from <a class="el" href="class_a_q_reader.html#a6746d86b29c04ff19032106323cdef6f" title="Obtains the next item from the queue. ">AQReader::retrieve()</a> this indicates whether the item was actually successfully committed. Items might not have been commited if, for example, the process that claimed the item was terminated before it was able to call <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a>.</li>
<li>When an item is retrieved from <a class="el" href="class_a_q_snapshot.html#ad2b0f8616beab3e8fd012031a712bd0a" title="Obtains a reference to one of the items in this snapshot. ">AQSnapshot::operator[]</a> this indicates whether the item was committed at the time the snapshot taken.</li>
</ul>
<p>When processing a retrieved item that has <a class="el" href="class_a_q_item.html#a09f66df9383cbeec05990270d2517397" title="Determines if this item was committed to the queue with a call to AQWriter::commit(). ">isCommitted()</a> as false the application shoud either discard the item entirely, or use some application-specific method to determine if the item is valid.</p>
<p>Note that in the case of queues with the <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> format option set if any one of the items was not committed then all the items in the linked list are maked as not committed.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the item was committed to the queue or false if it was not committed. If this item is not allocated the returned value is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3eb62c6b4c6dee0c2afafafd8bea06f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AQItem::isReleased </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this item has been released from the queue with a call to <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">AQReader::release()</a>. </p>
<p>This can only occur when an item is retrieved from <a class="el" href="class_a_q_snapshot.html#ad2b0f8616beab3e8fd012031a712bd0a" title="Obtains a reference to one of the items in this snapshot. ">AQSnapshot::operator[]</a> where the <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">AQReader::release()</a> had been called on that particular item.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this item has been released through <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">AQReader::release()</a> and false in all other cases. If this item is not allocated the returned value is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a71b8a01fb113490f2c96bf9a7cf60e8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_q_item.html">AQItem</a>* AQItem::last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a pointer to the last item in the linked list of items. </p>
<p>The returned pointer is always identical to this unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> has been set for the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>The last item. This is never NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e2e1414d09863cf3b733119a068dbb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t AQItem::linkIdentifier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the link identifier for this item. </p>
<p>When the queue is formatted with <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> this is used internally to track the linked list of items. In this case applications should not inspect nor rely on this value having any particular meaning.</p>
<p>When <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is not set, but <a class="el" href="class_a_q.html#a8c1b45770a35b703df2b1f1f17ca4745" title="When formatting a queue set this flag to attach a link identifier to each item. ">AQ::OPTION_LINK_IDENTIFIER</a> has been set then applications can set the link identifier when writing an item using <a class="el" href="class_a_q_writer_item.html#a52f19448fb3ca5fd9e1afbeb7d60027a" title="Sets the link identifier for this item. ">AQWriterItem::setLinkIdentifier()</a> and have the same value make available through this function when the item is read.</p>
<p>In all other cases this will return <a class="el" href="class_a_q_item.html#a987fe89fa76ce1733f1f8146873aead8" title="If a queue identifier is not known or has not been allocated this value will be stored in AQItem::que...">AQItem::QUEUE_IDENTIFIER_INVALID</a>. </p><dl class="section return"><dt>Returns</dt><dd>The link identifier for this item. If this item is not allocated the returned value is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a852962115eaa0b0bd8d356a682778afe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_q_item.html">AQItem</a>* AQItem::next </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a pointer to the next item in the linked list of items. </p>
<p>If this is the last item in the list then NULL is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The next item or NULL if there are no further items. NULL is always returned unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="a780c92d7ed552d69ac2a692d09ca3a2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_q_item.html">AQItem</a>&amp; AQItem::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_q_item.html">AQItem</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns this item so that it is an exact copy of another item. </p>
<p>Note that this does not create a new entry in the queue - it just copies the references from the other item. Regardless of how many copies are made only a single call to <a class="el" href="class_a_q_writer.html#a598bba1f79e007e038ab76d8939a5b56" title="Commits an item previously obtained via a claim() call to the queue so that it is available for consu...">AQWriter::commit()</a> or <a class="el" href="class_a_q_reader.html#aad5233986e056a2da7f23e282b7a2596" title="Releases the passed item so that it can be discarded from the queue. ">AQReader::release()</a> may be made. Accessing the memory of an item that has been committed or released elsewhere results in undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other item to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a395900d5781030372dfc231d2361d41c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char&amp; AQItem::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a reference to one of the bytes within this item. </p>
<p>This reference is only to be used for reading; writing the byte results in undefined behavior. The bytes in this item are allocated contiguously which means applications can do: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr = &amp;item[0];</div></div><!-- fragment --><p> In order to obtain a pointer to the underlying array.</p>
<p>No bounds checking is performed on access via this operator. As such the caller must ensure that idx is in the range 0 to (<a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> - 1) inclusive. The effect of accessing a byte outside of this range, even through the pointer taken in the example above, is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the byte to retreive. Must be in the range of 0 to (<a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> - 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the specified byte. If this item is not allocated or the provided index is outside the range of bytes in this item then the returned value is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a5afdc65d0570f2ee4bac6c3d61c2e16f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_q_item.html">AQItem</a>* AQItem::prev </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a pointer to the previous item in the linked list of items. </p>
<p>If this is the first item in the list then NULL is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The previous item or NULL if there are no further items. NULL is always returned unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> is set. </dd></dl>

</div>
</div>
<a class="anchor" id="a33029e27ef81601694a987648cd09f67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t AQItem::queueIdentifier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the unique queue identifier for this item. </p>
<p>The queue identifier is a a number in the range 0 - <a class="el" href="class_a_q_item.html#aaa5f97ad56a729c0ae1e8687111a9a40" title="The AQItem::queueIdentifier() will always return a value that fits within this bitmask. ">AQItem::QUEUE_IDENTIFIER_MASK</a> that uniquely identifies this item within the current queue state. So long as this item is not released from the queue, it is guarnteed that no other item will have the same queue identifier. </p><dl class="section return"><dt>Returns</dt><dd>The queue identifier for this item. If this item is not allocated the returned value is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a346237d15617f812d325c173f21892b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t AQItem::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the total number of bytes that have been stored by the user into this item. </p>
<p>This is the same as <a class="el" href="class_a_q_item.html#aba43b837efe456e423cf290b7bdae608" title="Obtains the total number of bytes that can be stored in this item. ">capacity()</a> unless <a class="el" href="class_a_q.html#adaa41d392733b3f668d4b5be8064e056" title="When formatting a queue set this flag to allow items to be extended in a linked list. ">AQ::OPTION_EXTENDABLE</a> has been configured for this queue. In that case the following rules apply:</p><ul>
<li>For each item in the linked list, except the last, <a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> exactly matches <a class="el" href="class_a_q_item.html#aba43b837efe456e423cf290b7bdae608" title="Obtains the total number of bytes that can be stored in this item. ">capacity()</a>.</li>
<li>For the last item in the linked list <a class="el" href="class_a_q_item.html#a346237d15617f812d325c173f21892b9" title="Obtains the total number of bytes that have been stored by the user into this item. ">size()</a> represents the highest byte that has been written into the item.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The size of this item in bytes. If this item is not allocated the returned value is undefined. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a987fe89fa76ce1733f1f8146873aead8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t AQItem::QUEUE_IDENTIFIER_INVALID = 0xFFFFFFFF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a queue identifier is not known or has not been allocated this value will be stored in <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a> or <a class="el" href="class_a_q_item.html#a8e2e1414d09863cf3b733119a068dbb8" title="Obtains the link identifier for this item. ">AQItem::linkIdentifier()</a>. </p>

</div>
</div>
<a class="anchor" id="aaa5f97ad56a729c0ae1e8687111a9a40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t AQItem::QUEUE_IDENTIFIER_MASK = 0x1FFFFFFF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a> will always return a value that fits within this bitmask. </p>
<p>The bitmask has the top 3 bits clear, thus all queue identifiers fall into the range 0 - AQ::QUEUE_IDENTIFIER_MASK. </p>

</div>
</div>
<a class="anchor" id="a53a0322677680ab691ff049dc69a2aa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t AQItem::QUEUE_IDENTIFIER_USER_BIT = 29</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first unused bit in the <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a>. </p>
<p>The queue identifier will never set this bit or an higher bit. </p>

</div>
</div>
<a class="anchor" id="a535cc166babbb9927ed075dc08eddaba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t AQItem::QUEUE_IDENTIFIER_USER_MASK = 0xE0000000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="class_a_q_item.html#a33029e27ef81601694a987648cd09f67" title="Obtains the unique queue identifier for this item. ">AQItem::queueIdentifier()</a> will always have the bits in this mask set to 0. </p>
<p>This is the inverse of AQ::QUEUE_IDENTIFIER_MASK. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>AQItem.h</li>
<li>AQItem.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 28 2016 14:39:04 for AQ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
